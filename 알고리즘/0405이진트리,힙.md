# 이진 트리

### 순회 종류

1. 중위 순회
2. 후위 순회
3. 전위 순회



```
수식 트리

수식을 표현하는 이진트리
수식 이진 트리라고 부르기도함
연산자는 루트노드이거나 가지노드
피연산자는 모드 잎 노드
```

### 트리의 개념

- 비선형 구조

- 원소들 간에 1:N 관계를 가지는 자료구조

- 원소들 간에 계층관계를 가지는 계층형 자료구조

- 상위 원소에서 하위원소로 내려가면서 확장되는 트리모양구조

- 한개 이상의 노드로 이루어진 유한 집합이다

  ### 노드 중 최상위 노드를 투르(root) 라고한다

```
노드(node)- 트리의 원소
 트리 T의 노드 - A,B,C,D,E,F,G,H,I
간선(edge)-노드를 연결하는 선 . 부모노드와 자식노드를 연결
루트노드 - 트리의 시작노드
 트리 T의 루트노드 -A
형제노드 - 같은 부모노드의 자식 노드들
조상노드 - 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
서브노드 - 부모노드와 연결된 간선을 끊었을때 생성되는 트리
자손노드 - 서브 트리에 있는 하위 레벨의 노드들
```

### 차수

- 노드의 차수 : 노드에 연결된 자식의 노드의수
- 트리의 차수 : 트리에 있는 노드 차수중 가장 큰값
- 단말 노드(리프노드) : 차수가 0인 노드, 자식노드가 없는 노드

### 높이

- 노드의 높이 : 루트에서 노드에 이르는 간선의 수, 노드의레벨
- 트리의 높이 : 트리에 있는 노드의 높이중에서 가장 큰값, 최대레벨



### 이진트리

- 모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리
- 각 노드가 자식 노드를 최대한 2개 가질수잇음
  - 왼쪽자식 노드
  - 오른쪽자식 노드

- 레벨 i 에서 노드의 최대 개수는 2^i 개
- 높이가 h인 이진 트리가 가질수있는 노드의 최소개수는 (h+1) 
- 최대 개수는 (2^h+1 - 1)

### 포화 이진 트리

- 모든 레베엘 노드가 포화상태로 차있는 이진트리
- 높이가 h일대 최대의 노드 개수가 (2^h+1 - 1) 의 노드를 가진 이진트리
- 루트를 1번으로 하여 (2^h+1 - 1) 까지 정해진 위치에 대한 노드 번호를 가짐



### 편향 이진 트리

- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식노드만 가진 이진트리



### 순회 traversal

- 순회란 트리의 각 노드를 중복되지 않게 전부 방문하는 것을 말함
- 트리는 비선형 구조이기때문에 선형구조에서와 같이 선후 연결관계를 알수없다
- 트리의 노드들을 체계적을 방문하는 것

 

## 전위 순회

- preorder traversal
- VLR
- 부모노드 방문후, 자식노드를 좌우 순서로 방문한다



## 중위 순회

- inoder traversal 
- LVR
- 왼쪽 자식노드- 부모노드- 오른쪽 자식 노드 순으로 방문

## 후위 순회

- postoder traversal

- LRV
- 자식노드를 좌우순서로 방문후 부모노드로 방문한다



```
전위 순회

수행 방법
1. 현재 노드n을 방문하여 처리한다 V
2. 현재 노드n의 왼쪽 서브트리로 이동한다 L
3. 현재 노드n의 오른쪽 서브트리로 이동한다 R

def preorder(node):
    global cnt
    if node != 0:
        print(node, end=" ")
        preorder(tree[node][0])
        preorder(tree[node][1])
```

```
중위 순회

수행 방법
1. 현재 노드n의 왼쪽 서브트리로 이동한다 L
2. 현재 노드n을 방문하여 처리한다 V
3. 현재 노드n의 오른쪽 서브트리로 이동한다 R

def inorder(node):
    if node != 0:
        inorder(tree[node][0])
        print(node, end=" ")
        inorder(tree[node][1])
        
```

```
후
위 순회

수행 방법
1. 현재 노드n의 왼쪽 서브트리로 이동한다 L
2. 현재 노드n의 오른쪽 서브트리로 이동한다 R
3. 현재 노드n을 방문하여 처리한다 V

def postorder(node):
    if node != 0:
        postorder(tree[node][0])
        postorder(tree[node][1])
        print(node, end=" ")
        
```

```
                               A
                         B            C
                      D     E      F      G
                     H I   J        K    L M
```

```
전위 순회VLR : A B D H I E J C F K G L M
중위 순회LVR : H D I B J E A F K C L G M
후위 순회LRV : H I D J E B K F L M G C A
```

### 배열

- 배열을 이용한 이진 트리의 표현
- 다점
  - 편향 이진트리의 경우에 사용하지 않는 배열 원소에 대한 메모리 공간 낭비 발생
  - 트리의 중간에 새로운 노드를 삽입하거나 기존의 노드를 삭제할 경우 배열의크기 변경이 어렵다



### 노드의 번호의 성질

- 노드 번호가i인 노드의 부모 노드 번호: i/2
- 노드 번호가 i인 노드의 왼쪽 자식 노드번호 : 2*i
- 노드 번호가 i인 노드의 오른쪽 자식 노드번호: 2*i +1
- 레벨 n의 노드 번호 시작 번호는 2^n

- ex) 노드번호 5 이면 부모노드 = 5 ,왼쪽자식=10 , 오른쪽자식 = 11



### 탐색연산

- 루트에서 시작한다
- 탐색할 키 값x를 루트 노드의 키값과 비교한다

```
키 값 x = 루트노드의 키값 : 원하는 원소를 찾았으므로 탐색연산 성공
키 값 x < 루트노드의 키값 : 루트노드의 왼쪽 서브트리에 대해서 탐색연산을 수행
키 값 x > 루트노드의 키값 : 루트노드의 오른쪽 서브트리에 대해서 탐색연산을 수행성공

서브트리에 대해서 순환적 탐색 연산을 반복
```



### 삽입 연산

1. 먼저 탐색 연산을 수행
   - 삽입할 원소와 같은 원소가 트리에있으면 삽입할수없으므로, 같은 원소가 트리에 있는 지 탐색하여 확인한ㄷ
   - 탐색에서 탐색 실패가 결정되는 위치가 삽입위치가된다

2. 탐색 실패한 위치에 원소를 삽입한다





- 탐색, 삽입,삭제 시간은 트리의 높이만큼 시간이걸린다
- 평균의 경우
  - 이진트리가 균형적으로 생성되어있는 경우
  - O(log n)
- 최악의 경우
  - 한쪽으로 치우친 경사 이진트리의 경우
  - O(n)
  - 순차 탐색과 시간 복잡도가 같다



# 힙

- 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰노드나 키값이 가장작은 노드를 찾기위해서 만든 자료구조



### 최대 힙

- 키값이 가장큰 노드를 찾기 위한 완전 이진트리
- 부모노드키값> 자식노드의 키값
- 루트노드 : 키값이 가장 큰 노드



### 최소 힙

- 키값이 가장작은 노드를 찾기 위한 완전 이진트리
- 부모노드키값< 자식노드의 키값
- 루트노드 : 키값이 가장 작은 노드